/*
 * generated by Xtext 2.10.0
 */
package zanshin.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import zanshin.dsl.dsl.Scope
import java.util.Hashtable
import java.io.File
import java.io.BufferedReader
import java.io.FileReader
import java.io.PrintWriter
import java.io.FileWriter
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.nio.file.StandardCopyOption

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DslGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(e:resource.allContents.toIterable.filter(Scope)){
			var String projectName = e.project.importedNamespace.replace(" ", "").replace("\"","");
			
			for(i:0 ..<e.simulation.size)
			{
				var simulationName = e.name.get(i)
				fsa.generateFile(
		   		"/" + projectName + "/" + simulationName + ".java", e.simulation(i)
		   		);
			}
			
			fsa.generateFile(
		   		 "/" + projectName + "/SimulatedTargetSystem" + ".java", e.TargetSystem
			);
			
			var String path =  "/" + projectName + "/Abstract" + projectName.toFirstUpper + "Simulation" + ".java";
			var String testPath = "../../dsl-test/teste.dsl/src-gen/"+projectName+"/"+"Abstract"+projectName.toFirstUpper + "Simulation" + ".java";
			var File file = new File(testPath);
			if(file.isFile()) { 
				//Activate in final version
			    //AbstractSimulationIncrement(e, testPath);
			    
			    //Delete in final version
			    fsa.generateFile(path, e.AbstractSimulation);
			}
			else{
				fsa.generateFile(path, e.AbstractSimulation);
			}
		}
	}
	
	def void AbstractSimulationIncrement(Scope scope, String path)
	{
		var String [] requirementsList = newArrayOfSize(500);
		var int lastIndex = 0;
		
		for (i:0 ..< scope.commands.size)
		{
			var command = scope.commands.get(i);
				
			for (j:0 ..< command.testtype.size)
			{
				if(!requirementsList.contains(command.testtype.get(j).name) && i < 500)
				{
					requirementsList.set(lastIndex,command.testtype.get(j).name);
					lastIndex++;
				}
			}
		}
		
	    var File file = new File(path); 
	    var File temp = File.createTempFile("temp-file", ".tmp", new File (file.getParent()));
	    var BufferedReader br = new BufferedReader(new FileReader(file));
	    var PrintWriter pw =  new PrintWriter(new FileWriter(temp));
	    var String line;
	    while ((line = br.readLine()) != null)
	    {
	        if(line.contains("protected static Object lock = new Object();"))
	        {
	            for (requirement:requirementsList)
	            {
	            	if(requirement != null)
	            	{	            	
						var String formatedRequeriment = requirement.replace("_"," ").toFirstUpper.replace(" ","")
						var String newLine = "	protected static final String " + requirement + " = " + formatedRequeriment + "\"; //$NON-NLS-1$"
						pw.println(newLine);
					}
				}
	            pw.println(line);
	        }
	        else
	        {
	        	pw.println(line);
	        }
	    }
	    br.close();
	    pw.close();
	    var Path source = Paths.get(file.getParent());
		var Path newdir = Paths.get(file.getParent());
		file.delete();
		Files.move(source, newdir.resolve(file.getName()), StandardCopyOption.REPLACE_EXISTING);
	    //file.delete();
	   	//temp.renameTo(file);
	}
	
 	def CharSequence simulation(Scope scope, int position){
		var String projectName = scope.project.importedNamespace.replace(" ", "").replace("\"","");
		var String simulationName = scope.name.get(position);
		
		var Hashtable<String, Integer> elementsList= new Hashtable<String, Integer>();
		var Hashtable<String, Integer> repeatedElements= new Hashtable<String, Integer>();
		
		var int startVector = 0
		var int finalPosition = 0
		var int index = 0
		var int shouldWaitIndex = 0
		
		if (scope.length.isEmpty){
			startVector = 0
			finalPosition = scope.commands.size
			shouldWaitIndex = scope.commands.size
		}
		else{
			startVector = position*scope.length.get(position)
			finalPosition = startVector+scope.length.get(position)
			shouldWaitIndex = scope.length.get(position)
		}
		
		for (i:0 ..< scope.commands.size)
		{
			var commands = scope.commands.get(i)
			
			for (z:0 ..< commands.testtype.size)
			{
				var String requirementWithID = commands.testtype.get(z).name + (i+1)
				
				if(!elementsList.containsKey(requirementWithID))
				{
					elementsList.put(requirementWithID,z)
				}
				else
				{
					repeatedElements.put(requirementWithID,z)
				}
			}
		}
		
		'''
		package it.unitn.disi.zanshin.simulation.cases.«projectName»;
		
		import it.unitn.disi.zanshin.simulation.Logger;
		import it.unitn.disi.zanshin.simulation.cases.SimulationPart;
		
		public final class «simulationName» extends Abstract«projectName.toFirstUpper»Simulation {
			
			private static final Logger log = new Logger(«simulationName».class);
			
			/** @see it.unitn.disi.zanshin.simulation.cases.AbstractSimulation#doInit() */
			@Override
			public void doInit() throws Exception {
				// Registers the «projectName» Simulation as target system in Zanshin.
				registerTargetSystem();
				«FOR i:startVector ..< finalPosition»
					«var commands = scope.commands.get(i)»
				// Adds the part «index = index+1» of the simulation to the list.
				parts.add(new SimulationPart() {
					@Override
					public void run() throws Exception {
						«IF commands.testtype.size != 0»
						// Creates a user session, as if someone were using the «projectName».
						sessionId = zanshin.createUserSession(targetSystemId);
						log.info("Created a new user session with id: {0}", sessionId); //$NON-NLS-1$
						«ENDIF»
						«IF commands.message == null»
						log.info("Empty Log"); //$NON-NLS-1$
						«ELSE»
						log.info("«commands.message.get(0).message»"); //$NON-NLS-1$
						«ENDIF»
						
					«FOR z:0 ..< commands.testtype.size»
					«var String simulationType = commands.testtype.get(z).simulationType»
					«var String requirement = commands.testtype.get(z).name»
					«var String requirementWithID = commands.testtype.get(z).name + (i+1)»
						«IF elementsList.containsKey(requirementWithID) && z <= elementsList.get(requirementWithID)»
						zanshin.logRequirementStart(targetSystemId, sessionId, «requirement»);
						«ENDIF»
						«IF commands.testtype.get(z).array»
						«FOR j:0 ..< commands.testtype.get(z).length»
						zanshin.logRequirement«simulationType»(targetSystemId, sessionId, «requirement»);
						«ENDFOR»
						«ELSE»
						zanshin.logRequirement«simulationType»(targetSystemId, sessionId, «requirement»);
						«ENDIF»
					«ENDFOR»
						«IF commands.testtype.size != 0»
						
						// Ends the user session.
						zanshin.disposeUserSession(targetSystemId, sessionId);
						«ENDIF»
					}
					@Override
					public boolean shouldWait() {
						«IF index == shouldWaitIndex»
						return false;
						«ELSE»
						return true;
						«ENDIF»
					}
				});
				«ENDFOR»
			}
		}
		'''
	}
	
	def CharSequence TargetSystem(Scope scope){
		var String projectName = scope.project.importedNamespace.replace(" ", "").replace("\"","");
		'''
		package it.unitn.disi.zanshin.simulation.cases.«projectName»;
		
		import java.util.Map;
		
		import it.unitn.disi.zanshin.simulation.SimulatedTargetSystem;
		
		public class «projectName.toFirstUpper»SimulatedTargetSystem extends SimulatedTargetSystem {
			/** The object in which the simulation thread is sleeping, and therefore used to "wake it up". */
			private Object lock;
		
			/** Constructor. */
			public «projectName.toFirstUpper»SimulatedTargetSystem(Object lock) {
				this.lock = lock;
			}
		
			/** @see it.unitn.disi.zanshin.simulation.SimulatedTargetSystem#initiate(java.lang.Long, java.lang.String) */
			@Override
			public void initiate(Long sessionId, String reqName) {
				super.initiate(sessionId, reqName);
		
				// Initiate is the last command of the Retry strategy, thus we should notify the simulation to continue, as this
				synchronized (lock) {
					lock.notifyAll();
				}
			}
		
			/** @see it.unitn.disi.zanshin.simulation.SimulatedTargetSystem#abort(java.lang.Long, java.lang.String) */
			@Override
			public void abort(Long sessionId, String awreqName) {
				super.abort(sessionId, awreqName);
				
				// After two attempts of the Retry strategy, Zanshin replies with an Abort, also for the AR1 simulation.
				synchronized (lock) {
					lock.notifyAll();
				}
			}
			
			public void applyConfig(Map<String, String> newConfig) {
				super.applyConfig(newConfig);
				
				// ApplyConfig is the last command of the Reconfiguration strategy, thus we should notify the simulation to
				// continue, as this strategy is selected to deal with failures of AR4.
				synchronized (lock) {
					lock.notifyAll();
				}		
			}
		}
		'''
	}
	
	def CharSequence AbstractSimulation(Scope scope){
		var String projectName = scope.project.importedNamespace.replace(" ", "").replace("\"","");
		var String [] requirementsList = newArrayOfSize(500);
		var int lastIndex = 0;
		
		for (i:0 ..< scope.commands.size)
		{
			var command = scope.commands.get(i);
				
			for (j:0 ..< command.testtype.size)
			{
				if(!requirementsList.contains(command.testtype.get(j).name) && i < 500)
				{
					requirementsList.set(lastIndex,command.testtype.get(j).name);
					lastIndex++;
				}
			}
		}
		
		'''
		package it.unitn.disi.zanshin.simulation.cases.«projectName»;
		
		import it.unitn.disi.zanshin.simulation.Logger;
		import it.unitn.disi.zanshin.simulation.SimulationUtils;
		import it.unitn.disi.zanshin.simulation.cases.AbstractSimulation;
		
		import java.io.IOException;
		
		public abstract class Abstract«projectName.toFirstUpper»Simulation extends AbstractSimulation {
			private static final Logger log = new Logger(Abstract«projectName.toFirstUpper»Simulation.class);
		
			protected static final String BASE_PATH = Abstract«projectName.toFirstUpper»Simulation.class.getPackage().getName().replace('.', '/') + '/';
		
			protected static final String META_MODEL_FILE_PATH = BASE_PATH + "«projectName».ecore"; //$NON-NLS-1$
		
			protected static final String MODEL_FILE_PATH = BASE_PATH + "model.«projectName»"; //$NON-NLS-1$
			
			«FOR requirement:requirementsList»
			«IF requirement != null»
			«var String formatedRequeriment = requirement.replace("_"," ").toFirstUpper.replace(" ","")»
			protected static final String «requirement» = "«formatedRequeriment»"; //$NON-NLS-1$
			«ENDIF»
			«ENDFOR»
			protected static Object lock = new Object();
		
			protected String targetSystemId;
		
			protected Long sessionId;
		
			protected void registerTargetSystem() throws IOException {
				// Registers the «projectName.toFirstUpper» simulation as target system in Zanshin, if not already registered.
				log.info("Registering the «projectName.toFirstUpper» Simulation as a target system in Zanshin!!!"); //$NON-NLS-1$
				targetSystemId = SimulationUtils.registerTargetSystem(zanshin, new «projectName.toFirstUpper»SimulatedTargetSystem(lock), META_MODEL_FILE_PATH, MODEL_FILE_PATH);
				log.info("Target system registered as: {0}", targetSystemId); //$NON-NLS-1$
			}
		
			/** @see it.unitn.disi.zanshin.simulation.cases.Simulation#getLock() */
			@Override
			public Object getLock() {
				return lock;
			}
		}
		'''
	}
}
