/*
 * generated by Xtext 2.10.0
 */
package zanshin.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import zanshin.dsl.dsl.Commands;
import zanshin.dsl.dsl.DslPackage;
import zanshin.dsl.dsl.Failure;
import zanshin.dsl.dsl.Log;
import zanshin.dsl.dsl.Model;
import zanshin.dsl.dsl.Project;
import zanshin.dsl.dsl.Scope;
import zanshin.dsl.dsl.Success;
import zanshin.dsl.dsl.TestQuantity;
import zanshin.dsl.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.COMMANDS:
				sequence_Commands(context, (Commands) semanticObject); 
				return; 
			case DslPackage.FAILURE:
				sequence_Failure(context, (Failure) semanticObject); 
				return; 
			case DslPackage.LOG:
				sequence_Log(context, (Log) semanticObject); 
				return; 
			case DslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DslPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case DslPackage.SCOPE:
				sequence_Scope(context, (Scope) semanticObject); 
				return; 
			case DslPackage.SUCCESS:
				sequence_Success(context, (Success) semanticObject); 
				return; 
			case DslPackage.TEST_QUANTITY:
				sequence_TestQuantity(context, (TestQuantity) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Commands returns Commands
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_Commands(ISerializationContext context, Commands semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.COMMANDS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.COMMANDS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandsAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Failure
	 *     Failure returns Failure
	 *
	 * Constraint:
	 *     (simulationType='Failure' (array?='[' length=INT?)? name=STRING)
	 */
	protected void sequence_Failure(ISerializationContext context, Failure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Log returns Log
	 *
	 * Constraint:
	 *     message=STRING
	 */
	protected void sequence_Log(ISerializationContext context, Log semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.LOG__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.LOG__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogAccess().getMessageSTRINGTerminalRuleCall_1_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     dsl+=Scope+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROJECT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROJECT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Scope
	 *
	 * Constraint:
	 *     (project=Project name=ID length=INT? (testquantity+=TestQuantity? commands+=Commands message+=Log?)*)
	 */
	protected void sequence_Scope(ISerializationContext context, Scope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Success
	 *     Success returns Success
	 *
	 * Constraint:
	 *     (simulationType='Success' (array?='[' length=INT?)? name=STRING)
	 */
	protected void sequence_Success(ISerializationContext context, Success semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestQuantity returns TestQuantity
	 *
	 * Constraint:
	 *     number=INT
	 */
	protected void sequence_TestQuantity(ISerializationContext context, TestQuantity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TEST_QUANTITY__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TEST_QUANTITY__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestQuantityAccess().getNumberINTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
}
